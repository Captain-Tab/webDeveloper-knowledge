## 目录
1. [浏览器进程](#浏览器进程)
2. [JS是单线程](#JS是单线程)
3. [JS引擎](#JS引擎)
4. [Stack栈数据结构](#Stack栈数据结构)
5. [Heap堆数据结构](#Heap堆数据结构)
6. [Queue队列数据结构](#Queue队列数据结构)
7. [变量的存放](#变量的存放)
8. [内存空间管理](#内存空间管理)
9. [window全局对象](#window全局对象)
10. [更多信息](#更多信息)

### 浏览器进程
#### Chrome.exe程序
1. 用户双击点击`Chrome`图标，运行`Chrome.exe`程序
2. 开启`Chrome`进程，为主进程
3. 主进程开启辅助进程，例如网络服务，`GPU`加速
4. 新建网页，可能开启一个子进程

#### 浏览器的功能
1. 发起请求，下载`HTML`，解析`HTML`，下载`CSS`,解析`CSS`，渲染界面，下载`JS`，解析`JS`，执行`JS`等
2. 运行功能模块，例如：用户界面，渲染引擎，`JS`引擎等，存储等。**其中渲染引擎复制HTML和CSS的渲染，JS复制JS的渲染等。**
3. 功能模块是处于不用的线程，线程比进程更小
4. 如果进程是车间，线程则是车间的流水线

### JS是单线程
同一个时间只能做一件事。那么，为什么`JavaScript`不能有多个线程呢？这样能提高效率啊。
1. `JavaScript`的单线程，与它的用途有关。作为浏览器脚本语言，`JavaScript`的主要用途是与用户互动，以及操作`DOM`。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定`JavaScript`同时有两个线程，一个线程在某个`DOM`节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
2. 所以，为了避免复杂性，从一诞生，`JavaScript`就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
3. 为了利用多核`CPU`的计算能力，`HTML5`提出`Web Worker`标准，允许`JavaScript`脚本创建多个线程，但是子线程完全受主线程控制，且不得操作`DOM`。所以，这个新标准并没有改变`JavaScript`单线程的本质。

### JS引擎
#### JS V8引擎
* `Node.js` 和 `Chrome`使用`V8`引擎，`C++`编写
* `Firefox`使用的是`SpiderMonkey`,`C++`编写
* `Safari`使用的是`JavaScriptCore`
* `IE` 使用的是`Chakra(JScript9)`
* `Edge`用的是`Chakra(JavaScript)`

#### 引擎的功能
* 编译：将`JS`代码编译为机器能执行的字节码或者机器码
* 优化：提高运行速度
* 执行：执行上面的字节码或者机器码
* 垃圾回收机制：回收`JS`的内存，再次利用

### Stack栈数据结构
结构就是后进先出 **Last-in,Fist-out**，每个数据按顺序存放。例如，乒乓盒子中最顶层的球`5`，最后一个放置进去，却第一个被拿出来使用。如果想拿到最底部的乒乓球`1`，需要把上面的球全部取出来，让乒乓球`1`处于盒子顶层
![](https://user-gold-cdn.xitu.io/2020/2/9/1702871764324c8a?w=700&h=550&f=webp&s=12678)

### Heap堆数据结构
结构是一种树状结构，每个数据按随机数据存放。存取数据的方式和书架，书非常相似。例如，我们只需要知道书的名字，就可以把书给取出来。`JSON`格式的数据中，存储的`key-value`是无序的。

### Queue队列数据结构
队列是一种**First-in,First-out**的数据结构，这是事件循环（Event Loop)的基础结构
![](https://user-gold-cdn.xitu.io/2020/2/9/170287b3be6e5443?w=1000&h=373&f=webp&s=8212)

### 变量的存放
#### 基本类型--> 存储于栈
基本类型一共有`6`种，分别为：**Undefined、Null、Boolean、Number 、String、Symbol**。因为这些类型在内存中占有固定的大小空间，通过按值来访问
#### 引用类型--> 存储于堆
引用类型有**对象object, 数组Array**。**当查询引用类型的变量时，先从栈中读取内存地址， 然后再通过地址找到堆中的值**。因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。在计算机的数据结构中，栈的运算速度比堆快，因为**对象object, 数组Array**的结构复杂，可以扩展，添加属性，增删改查。
通过引用的方式，先查找栈，再找到堆中的 实际对象，不影响效率。
![](https://user-gold-cdn.xitu.io/2020/2/9/1702881f27b98820?w=492&h=326&f=png&s=46652)

#### 实际问题
问题1:
```
var a = 20;
var b = a;
b = 30;
// 这时a的值是多少？
// 答案:20
```
`a`、`b`都是基本类型，它们的值是存储在栈中的，`a`、`b`分别有各自独立的栈空间，所以修改了`b`的值以后，`a`的值并不会发生变化。

问题2:
```
var a = { name: '前端开发' }
var b = a;
b.name = '进阶';

// 这时a.name的值是多少
// 答案:进阶
```
`a`、`b`都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改`b.name`的值后，相应的`a.name`也就发生了改变。

问题3：
```
var a = { name: '前端开发' }
var b = a;
a = null;

// 这时b的值是多少
// 答案:`{ name: '前端开发' }`
```
首先要说明的是`null`是基本类型，`a = null`之后只是把`a`存储在栈内存中地址改变成了基本类型`null`，并不会影响堆内存中的对象，所以`b`的值不受影响。

问题4:
```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// 这时 a.x 的值是多少
b.x 	// 这时 b.x 的值是多少
```
答案: [知乎答案与讲解](https://www.zhihu.com/question/41220520)

### 内存空间管理
`JavaScript`的内存生命周期是：
1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放、归还

`JavaScript`有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用`a = null`其实仅仅只是做了一个释放引用的操作，让`a` 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。

### window全局对象
**在全局作用域中声明的变量、函数都是window对象的属性和方法。**
*  `window`对象是相对于`web`浏览器而言的，依赖于浏览器，在浏览器中全局对象指的就是`window`对象
* `window`对象和`winodw`变量是两个东西，`window`变量存放在`Stack`栈内存，存有指向`window`对象的地址。而`window`对象存在堆内存中。可以修改为`var x = winow`,则`X`指向`window`对象。`console`和`console`对象，`object`和`object`对象同理
![](https://user-gold-cdn.xitu.io/2020/2/9/1702977938c3d02a?w=470&h=235&f=jpeg&s=25460)

### 更多信息
>[yygmind Github博客](https://github.com/yygmind/blog/issues/14)

>[简书 博客](https://www.jianshu.com/p/996671d4dcc4)

>[JS引擎运行机制](https://www.jianshu.com/p/f625ec90253a)

>[V8引擎是如何工作的？](https://blog.fundebug.com/2019/07/16/how-does-v8-work/)