### Computed 计算属性

计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点

- 数据可以进行逻辑处理，减少模板中计算逻辑。
- 对计算属性中的数据进行监视
- 依赖固定的数据类型（响应式数据）

计算属性由两部分组成：`get`和`set`，分别用来获取计算属性和设置计算属性。默认只有`get`，如果需要`set`，要自己添加。另外`set`设置属性，并不是直接修改计算属性，而是修改它的依赖。计算属性可以像绑定普通属性一样在模板中绑定计算属性，在定义上有区别：计算属性的属性值必须是一个函数
只要其中任一数据变化，计算属性就会重新执行，视图也会更新

两者最主要的区别：`computed` 是可以缓存的，`methods` 不能缓存；**只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行**。网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，计算属性可以通过闭包来实现传参：

- 只要页面重新渲染，方法会被调用一次。如果没有渲染，则不会执行
- 只要计算属性依赖的数据没有发生变化，不管页面是否渲染，计算属性都不能执行。

### watch 监听属性

`Vue`提供了一种更通用的方式来观察和响应`Vue` 实例上的数据变动：监听属性`watch`。`watch`中可以执行任何逻辑，如函数节流，`Ajax`异步获取数据，甚至操作 `DOM`（不建议）

使用 `watch` 来监听数据变化的时候除了常用到`handler`回调，其实其还有两个参数，便是：

- `deep` 设置为 `true` 用于监听对象内部值的变化
- `immediate` 设置为 `true` 将立即以表达式的当前值触发回调

下面的代码中我们修改了 `obj` 对象中 `a` 属性的值，我们可以触发其 `watch` 中的 `handler` 回调输出新的对象，而如果不加 `deep: true`，我们只能监听 `obj` 的改变，并不会触发回调。同时我们也添加了 `immediate: true` 配置，其会立即以 `obj` 的当前值触发回调

```
<template>
    <button @click="obj.a = 2">修改</button>
</template>
<script>
export default {
    data() {
        return {
            obj: {
                a: 1,
            }
        }
    },
    watch: {
        obj: {
            handler: function(newVal, oldVal) {
                console.log(newVal);
            },
            deep: true,
            immediate: true
        }
    }
}
</script>
```

### computed vs watch

- `watch`：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。
- `computed`：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。
- 计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。`watch`也可以检测`computed`属性。
